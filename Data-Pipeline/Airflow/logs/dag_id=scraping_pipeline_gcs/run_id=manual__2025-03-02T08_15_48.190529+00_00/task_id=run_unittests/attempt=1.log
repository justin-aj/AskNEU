[2025-03-02T08:15:52.914+0000] {local_task_job_runner.py:123} INFO - ::group::Pre task execution logs
[2025-03-02T08:15:52.925+0000] {taskinstance.py:2614} INFO - Dependencies all met for dep_context=non-requeueable deps ti=<TaskInstance: scraping_pipeline_gcs.run_unittests manual__2025-03-02T08:15:48.190529+00:00 [queued]>
[2025-03-02T08:15:52.929+0000] {taskinstance.py:2614} INFO - Dependencies all met for dep_context=requeueable deps ti=<TaskInstance: scraping_pipeline_gcs.run_unittests manual__2025-03-02T08:15:48.190529+00:00 [queued]>
[2025-03-02T08:15:52.929+0000] {taskinstance.py:2867} INFO - Starting attempt 1 of 3
[2025-03-02T08:15:52.934+0000] {taskinstance.py:2890} INFO - Executing <Task(BashOperator): run_unittests> on 2025-03-02 08:15:48.190529+00:00
[2025-03-02T08:15:52.943+0000] {standard_task_runner.py:104} INFO - Running: ['***', 'tasks', 'run', 'scraping_pipeline_gcs', 'run_unittests', 'manual__2025-03-02T08:15:48.190529+00:00', '--job-id', '52', '--raw', '--subdir', 'DAGS_FOLDER/dag.py', '--cfg-path', '/tmp/tmpm8e5zrab']
[2025-03-02T08:15:52.944+0000] {standard_task_runner.py:105} INFO - Job 52: Subtask run_unittests
[2025-03-02T08:15:52.940+0000] {warnings.py:112} WARNING - /home/***/.local/lib/python3.12/site-packages/***/task/task_runner/standard_task_runner.py:70: DeprecationWarning: This process (pid=1668) is multi-threaded, use of fork() may lead to deadlocks in the child.
  pid = os.fork()

[2025-03-02T08:15:52.945+0000] {standard_task_runner.py:72} INFO - Started process 1670 to run task
[2025-03-02T08:15:52.969+0000] {task_command.py:467} INFO - Running <TaskInstance: scraping_pipeline_gcs.run_unittests manual__2025-03-02T08:15:48.190529+00:00 [running]> on host 8b8ee4ab00d2
[2025-03-02T08:15:53.328+0000] {taskinstance.py:3134} INFO - Exporting env vars: AIRFLOW_CTX_DAG_OWNER='***' AIRFLOW_CTX_DAG_ID='scraping_pipeline_gcs' AIRFLOW_CTX_TASK_ID='run_unittests' AIRFLOW_CTX_EXECUTION_DATE='2025-03-02T08:15:48.190529+00:00' AIRFLOW_CTX_TRY_NUMBER='1' AIRFLOW_CTX_DAG_RUN_ID='manual__2025-03-02T08:15:48.190529+00:00'
[2025-03-02T08:15:53.329+0000] {logging_mixin.py:190} INFO - Task instance is in running state
[2025-03-02T08:15:53.330+0000] {logging_mixin.py:190} INFO -  Previous state of the Task instance: queued
[2025-03-02T08:15:53.330+0000] {logging_mixin.py:190} INFO - Current task name:run_unittests state:running start_date:2025-03-02 08:15:52.925773+00:00
[2025-03-02T08:15:53.331+0000] {logging_mixin.py:190} INFO - Dag name:scraping_pipeline_gcs and current dag run status:running
[2025-03-02T08:15:53.331+0000] {taskinstance.py:732} INFO - ::endgroup::
[2025-03-02T08:15:53.333+0000] {subprocess.py:78} INFO - Tmp dir root location: /tmp
[2025-03-02T08:15:53.335+0000] {subprocess.py:88} INFO - Running command: ['/usr/bin/bash', '-c', 'pytest /opt/***/dags/src/test_scraper.py']
[2025-03-02T08:15:53.349+0000] {subprocess.py:99} INFO - Output:
[2025-03-02T08:15:54.411+0000] {subprocess.py:106} INFO - ============================= test session starts ==============================
[2025-03-02T08:15:54.414+0000] {subprocess.py:106} INFO - platform linux -- Python 3.12.9, pytest-8.3.4, pluggy-1.5.0
[2025-03-02T08:15:54.415+0000] {subprocess.py:106} INFO - rootdir: /opt/***/dags/src
[2025-03-02T08:15:54.415+0000] {subprocess.py:106} INFO - plugins: time-machine-2.16.0, anyio-4.8.0
[2025-03-02T08:15:54.415+0000] {subprocess.py:106} INFO - collected 7 items
[2025-03-02T08:15:54.415+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.877+0000] {subprocess.py:106} INFO - ../../opt/***/dags/src/test_scraper.py ....F..                       [100%]
[2025-03-02T08:15:54.879+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.881+0000] {subprocess.py:106} INFO - =================================== FAILURES ===================================
[2025-03-02T08:15:54.881+0000] {subprocess.py:106} INFO - _____________________________ test_start_webdriver _____________________________
[2025-03-02T08:15:54.882+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.882+0000] {subprocess.py:106} INFO - self = <urllib3.connection.HTTPConnection object at 0xffff8d35a690>
[2025-03-02T08:15:54.883+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.883+0000] {subprocess.py:106} INFO -     def _new_conn(self) -> socket.socket:
[2025-03-02T08:15:54.883+0000] {subprocess.py:106} INFO -         """Establish a socket connection and set nodelay settings on it.
[2025-03-02T08:15:54.884+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.884+0000] {subprocess.py:106} INFO -         :return: New socket connection.
[2025-03-02T08:15:54.885+0000] {subprocess.py:106} INFO -         """
[2025-03-02T08:15:54.885+0000] {subprocess.py:106} INFO -         try:
[2025-03-02T08:15:54.885+0000] {subprocess.py:106} INFO - >           sock = connection.create_connection(
[2025-03-02T08:15:54.885+0000] {subprocess.py:106} INFO -                 (self._dns_host, self.port),
[2025-03-02T08:15:54.886+0000] {subprocess.py:106} INFO -                 self.timeout,
[2025-03-02T08:15:54.886+0000] {subprocess.py:106} INFO -                 source_address=self.source_address,
[2025-03-02T08:15:54.886+0000] {subprocess.py:106} INFO -                 socket_options=self.socket_options,
[2025-03-02T08:15:54.887+0000] {subprocess.py:106} INFO -             )
[2025-03-02T08:15:54.887+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.887+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connection.py:198:
[2025-03-02T08:15:54.887+0000] {subprocess.py:106} INFO - _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
[2025-03-02T08:15:54.888+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/util/connection.py:60: in create_connection
[2025-03-02T08:15:54.888+0000] {subprocess.py:106} INFO -     for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
[2025-03-02T08:15:54.888+0000] {subprocess.py:106} INFO - _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
[2025-03-02T08:15:54.888+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.888+0000] {subprocess.py:106} INFO - host = 'remote_chromedriver', port = 4444, family = <AddressFamily.AF_UNSPEC: 0>
[2025-03-02T08:15:54.889+0000] {subprocess.py:106} INFO - type = <SocketKind.SOCK_STREAM: 1>, proto = 0, flags = 0
[2025-03-02T08:15:54.889+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.889+0000] {subprocess.py:106} INFO -     def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
[2025-03-02T08:15:54.889+0000] {subprocess.py:106} INFO -         """Resolve host and port into list of address info entries.
[2025-03-02T08:15:54.889+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.889+0000] {subprocess.py:106} INFO -         Translate the host/port argument into a sequence of 5-tuples that contain
[2025-03-02T08:15:54.889+0000] {subprocess.py:106} INFO -         all the necessary arguments for creating a socket connected to that service.
[2025-03-02T08:15:54.890+0000] {subprocess.py:106} INFO -         host is a domain name, a string representation of an IPv4/v6 address or
[2025-03-02T08:15:54.890+0000] {subprocess.py:106} INFO -         None. port is a string service name such as 'http', a numeric port number or
[2025-03-02T08:15:54.890+0000] {subprocess.py:106} INFO -         None. By passing None as the value of host and port, you can pass NULL to
[2025-03-02T08:15:54.890+0000] {subprocess.py:106} INFO -         the underlying C API.
[2025-03-02T08:15:54.890+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.890+0000] {subprocess.py:106} INFO -         The family, type and proto arguments can be optionally specified in order to
[2025-03-02T08:15:54.890+0000] {subprocess.py:106} INFO -         narrow the list of addresses returned. Passing zero as a value for each of
[2025-03-02T08:15:54.890+0000] {subprocess.py:106} INFO -         these arguments selects the full range of results.
[2025-03-02T08:15:54.890+0000] {subprocess.py:106} INFO -         """
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO -         # We override this function since we want to translate the numeric family
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO -         # and socket type values to enum constants.
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO -         addrlist = []
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO - >       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO - E       socket.gaierror: [Errno -2] Name or service not known
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO - /usr/local/lib/python3.12/socket.py:978: gaierror
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO - The above exception was the direct cause of the following exception:
[2025-03-02T08:15:54.891+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.892+0000] {subprocess.py:106} INFO - self = <urllib3.connectionpool.HTTPConnectionPool object at 0xffff8d35acc0>
[2025-03-02T08:15:54.892+0000] {subprocess.py:106} INFO - method = 'POST', url = '/wd/hub/session'
[2025-03-02T08:15:54.892+0000] {subprocess.py:106} INFO - body = '{"capabilities": {"firstMatch": [{}], "alwaysMatch": {"browserName": "chrome", "pageLoadStrategy": "normal", "goog:ch...la/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36"]}}}}'
[2025-03-02T08:15:54.892+0000] {subprocess.py:106} INFO - headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.28.1 (python linux)', 'Connection': 'keep-alive'})
[2025-03-02T08:15:54.892+0000] {subprocess.py:106} INFO - retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
[2025-03-02T08:15:54.892+0000] {subprocess.py:106} INFO - redirect = False, assert_same_host = False, timeout = None, pool_timeout = None
[2025-03-02T08:15:54.892+0000] {subprocess.py:106} INFO - release_conn = True, chunked = False, body_pos = None, preload_content = True
[2025-03-02T08:15:54.892+0000] {subprocess.py:106} INFO - decode_content = True, response_kw = {}
[2025-03-02T08:15:54.892+0000] {subprocess.py:106} INFO - parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/wd/hub/session', query=None, fragment=None)
[2025-03-02T08:15:54.893+0000] {subprocess.py:106} INFO - destination_scheme = None, conn = None, release_this_conn = True
[2025-03-02T08:15:54.893+0000] {subprocess.py:106} INFO - http_tunnel_required = False, err = None, clean_exit = False
[2025-03-02T08:15:54.893+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.893+0000] {subprocess.py:106} INFO -     def urlopen(  # type: ignore[override]
[2025-03-02T08:15:54.893+0000] {subprocess.py:106} INFO -         self,
[2025-03-02T08:15:54.893+0000] {subprocess.py:106} INFO -         method: str,
[2025-03-02T08:15:54.893+0000] {subprocess.py:106} INFO -         url: str,
[2025-03-02T08:15:54.894+0000] {subprocess.py:106} INFO -         body: _TYPE_BODY | None = None,
[2025-03-02T08:15:54.894+0000] {subprocess.py:106} INFO -         headers: typing.Mapping[str, str] | None = None,
[2025-03-02T08:15:54.894+0000] {subprocess.py:106} INFO -         retries: Retry | bool | int | None = None,
[2025-03-02T08:15:54.894+0000] {subprocess.py:106} INFO -         redirect: bool = True,
[2025-03-02T08:15:54.895+0000] {subprocess.py:106} INFO -         assert_same_host: bool = True,
[2025-03-02T08:15:54.895+0000] {subprocess.py:106} INFO -         timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
[2025-03-02T08:15:54.895+0000] {subprocess.py:106} INFO -         pool_timeout: int | None = None,
[2025-03-02T08:15:54.895+0000] {subprocess.py:106} INFO -         release_conn: bool | None = None,
[2025-03-02T08:15:54.896+0000] {subprocess.py:106} INFO -         chunked: bool = False,
[2025-03-02T08:15:54.896+0000] {subprocess.py:106} INFO -         body_pos: _TYPE_BODY_POSITION | None = None,
[2025-03-02T08:15:54.896+0000] {subprocess.py:106} INFO -         preload_content: bool = True,
[2025-03-02T08:15:54.896+0000] {subprocess.py:106} INFO -         decode_content: bool = True,
[2025-03-02T08:15:54.896+0000] {subprocess.py:106} INFO -         **response_kw: typing.Any,
[2025-03-02T08:15:54.896+0000] {subprocess.py:106} INFO -     ) -> BaseHTTPResponse:
[2025-03-02T08:15:54.897+0000] {subprocess.py:106} INFO -         """
[2025-03-02T08:15:54.897+0000] {subprocess.py:106} INFO -         Get a connection from the pool and perform an HTTP request. This is the
[2025-03-02T08:15:54.897+0000] {subprocess.py:106} INFO -         lowest level call for making a request, so you'll need to specify all
[2025-03-02T08:15:54.897+0000] {subprocess.py:106} INFO -         the raw details.
[2025-03-02T08:15:54.897+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.897+0000] {subprocess.py:106} INFO -         .. note::
[2025-03-02T08:15:54.897+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.897+0000] {subprocess.py:106} INFO -            More commonly, it's appropriate to use a convenience method
[2025-03-02T08:15:54.898+0000] {subprocess.py:106} INFO -            such as :meth:`request`.
[2025-03-02T08:15:54.898+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.898+0000] {subprocess.py:106} INFO -         .. note::
[2025-03-02T08:15:54.898+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.898+0000] {subprocess.py:106} INFO -            `release_conn` will only behave as expected if
[2025-03-02T08:15:54.898+0000] {subprocess.py:106} INFO -            `preload_content=False` because we want to make
[2025-03-02T08:15:54.898+0000] {subprocess.py:106} INFO -            `preload_content=False` the default behaviour someday soon without
[2025-03-02T08:15:54.898+0000] {subprocess.py:106} INFO -            breaking backwards compatibility.
[2025-03-02T08:15:54.898+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.899+0000] {subprocess.py:106} INFO -         :param method:
[2025-03-02T08:15:54.899+0000] {subprocess.py:106} INFO -             HTTP request method (such as GET, POST, PUT, etc.)
[2025-03-02T08:15:54.899+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.899+0000] {subprocess.py:106} INFO -         :param url:
[2025-03-02T08:15:54.899+0000] {subprocess.py:106} INFO -             The URL to perform the request on.
[2025-03-02T08:15:54.899+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.899+0000] {subprocess.py:106} INFO -         :param body:
[2025-03-02T08:15:54.899+0000] {subprocess.py:106} INFO -             Data to send in the request body, either :class:`str`, :class:`bytes`,
[2025-03-02T08:15:54.899+0000] {subprocess.py:106} INFO -             an iterable of :class:`str`/:class:`bytes`, or a file-like object.
[2025-03-02T08:15:54.900+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.900+0000] {subprocess.py:106} INFO -         :param headers:
[2025-03-02T08:15:54.900+0000] {subprocess.py:106} INFO -             Dictionary of custom headers to send, such as User-Agent,
[2025-03-02T08:15:54.900+0000] {subprocess.py:106} INFO -             If-None-Match, etc. If None, pool headers are used. If provided,
[2025-03-02T08:15:54.900+0000] {subprocess.py:106} INFO -             these headers completely replace any pool-specific headers.
[2025-03-02T08:15:54.900+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.900+0000] {subprocess.py:106} INFO -         :param retries:
[2025-03-02T08:15:54.900+0000] {subprocess.py:106} INFO -             Configure the number of retries to allow before raising a
[2025-03-02T08:15:54.901+0000] {subprocess.py:106} INFO -             :class:`~urllib3.exceptions.MaxRetryError` exception.
[2025-03-02T08:15:54.901+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.901+0000] {subprocess.py:106} INFO -             If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
[2025-03-02T08:15:54.901+0000] {subprocess.py:106} INFO -             :class:`~urllib3.util.retry.Retry` object for fine-grained control
[2025-03-02T08:15:54.901+0000] {subprocess.py:106} INFO -             over different types of retries.
[2025-03-02T08:15:54.901+0000] {subprocess.py:106} INFO -             Pass an integer number to retry connection errors that many times,
[2025-03-02T08:15:54.901+0000] {subprocess.py:106} INFO -             but no other types of errors. Pass zero to never retry.
[2025-03-02T08:15:54.901+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.902+0000] {subprocess.py:106} INFO -             If ``False``, then retries are disabled and any exception is raised
[2025-03-02T08:15:54.902+0000] {subprocess.py:106} INFO -             immediately. Also, instead of raising a MaxRetryError on redirects,
[2025-03-02T08:15:54.902+0000] {subprocess.py:106} INFO -             the redirect response will be returned.
[2025-03-02T08:15:54.902+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.902+0000] {subprocess.py:106} INFO -         :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
[2025-03-02T08:15:54.902+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.902+0000] {subprocess.py:106} INFO -         :param redirect:
[2025-03-02T08:15:54.903+0000] {subprocess.py:106} INFO -             If True, automatically handle redirects (status codes 301, 302,
[2025-03-02T08:15:54.903+0000] {subprocess.py:106} INFO -             303, 307, 308). Each redirect counts as a retry. Disabling retries
[2025-03-02T08:15:54.903+0000] {subprocess.py:106} INFO -             will disable redirect, too.
[2025-03-02T08:15:54.903+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.903+0000] {subprocess.py:106} INFO -         :param assert_same_host:
[2025-03-02T08:15:54.903+0000] {subprocess.py:106} INFO -             If ``True``, will make sure that the host of the pool requests is
[2025-03-02T08:15:54.903+0000] {subprocess.py:106} INFO -             consistent else will raise HostChangedError. When ``False``, you can
[2025-03-02T08:15:54.903+0000] {subprocess.py:106} INFO -             use the pool on an HTTP proxy and request foreign hosts.
[2025-03-02T08:15:54.904+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.904+0000] {subprocess.py:106} INFO -         :param timeout:
[2025-03-02T08:15:54.904+0000] {subprocess.py:106} INFO -             If specified, overrides the default timeout for this one
[2025-03-02T08:15:54.904+0000] {subprocess.py:106} INFO -             request. It may be a float (in seconds) or an instance of
[2025-03-02T08:15:54.904+0000] {subprocess.py:106} INFO -             :class:`urllib3.util.Timeout`.
[2025-03-02T08:15:54.904+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.904+0000] {subprocess.py:106} INFO -         :param pool_timeout:
[2025-03-02T08:15:54.904+0000] {subprocess.py:106} INFO -             If set and the pool is set to block=True, then this method will
[2025-03-02T08:15:54.905+0000] {subprocess.py:106} INFO -             block for ``pool_timeout`` seconds and raise EmptyPoolError if no
[2025-03-02T08:15:54.905+0000] {subprocess.py:106} INFO -             connection is available within the time period.
[2025-03-02T08:15:54.905+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.905+0000] {subprocess.py:106} INFO -         :param bool preload_content:
[2025-03-02T08:15:54.905+0000] {subprocess.py:106} INFO -             If True, the response's body will be preloaded into memory.
[2025-03-02T08:15:54.905+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.905+0000] {subprocess.py:106} INFO -         :param bool decode_content:
[2025-03-02T08:15:54.905+0000] {subprocess.py:106} INFO -             If True, will attempt to decode the body based on the
[2025-03-02T08:15:54.905+0000] {subprocess.py:106} INFO -             'content-encoding' header.
[2025-03-02T08:15:54.906+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.906+0000] {subprocess.py:106} INFO -         :param release_conn:
[2025-03-02T08:15:54.906+0000] {subprocess.py:106} INFO -             If False, then the urlopen call will not release the connection
[2025-03-02T08:15:54.906+0000] {subprocess.py:106} INFO -             back into the pool once a response is received (but will release if
[2025-03-02T08:15:54.906+0000] {subprocess.py:106} INFO -             you read the entire contents of the response such as when
[2025-03-02T08:15:54.906+0000] {subprocess.py:106} INFO -             `preload_content=True`). This is useful if you're not preloading
[2025-03-02T08:15:54.906+0000] {subprocess.py:106} INFO -             the response's content immediately. You will need to call
[2025-03-02T08:15:54.906+0000] {subprocess.py:106} INFO -             ``r.release_conn()`` on the response ``r`` to return the connection
[2025-03-02T08:15:54.907+0000] {subprocess.py:106} INFO -             back into the pool. If None, it takes the value of ``preload_content``
[2025-03-02T08:15:54.907+0000] {subprocess.py:106} INFO -             which defaults to ``True``.
[2025-03-02T08:15:54.907+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.907+0000] {subprocess.py:106} INFO -         :param bool chunked:
[2025-03-02T08:15:54.907+0000] {subprocess.py:106} INFO -             If True, urllib3 will send the body using chunked transfer
[2025-03-02T08:15:54.907+0000] {subprocess.py:106} INFO -             encoding. Otherwise, urllib3 will send the body using the standard
[2025-03-02T08:15:54.907+0000] {subprocess.py:106} INFO -             content-length form. Defaults to False.
[2025-03-02T08:15:54.907+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.907+0000] {subprocess.py:106} INFO -         :param int body_pos:
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO -             Position to seek to in file-like body in the event of a retry or
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO -             redirect. Typically this won't need to be set because urllib3 will
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO -             auto-populate the value when needed.
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO -         """
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO -         parsed_url = parse_url(url)
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO -         destination_scheme = parsed_url.scheme
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO -         if headers is None:
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO -             headers = self.headers
[2025-03-02T08:15:54.908+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.909+0000] {subprocess.py:106} INFO -         if not isinstance(retries, Retry):
[2025-03-02T08:15:54.909+0000] {subprocess.py:106} INFO -             retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
[2025-03-02T08:15:54.909+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.909+0000] {subprocess.py:106} INFO -         if release_conn is None:
[2025-03-02T08:15:54.909+0000] {subprocess.py:106} INFO -             release_conn = preload_content
[2025-03-02T08:15:54.909+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.909+0000] {subprocess.py:106} INFO -         # Check host
[2025-03-02T08:15:54.909+0000] {subprocess.py:106} INFO -         if assert_same_host and not self.is_same_host(url):
[2025-03-02T08:15:54.909+0000] {subprocess.py:106} INFO -             raise HostChangedError(self, url, retries)
[2025-03-02T08:15:54.910+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.910+0000] {subprocess.py:106} INFO -         # Ensure that the URL we're connecting to is properly encoded
[2025-03-02T08:15:54.910+0000] {subprocess.py:106} INFO -         if url.startswith("/"):
[2025-03-02T08:15:54.910+0000] {subprocess.py:106} INFO -             url = to_str(_encode_target(url))
[2025-03-02T08:15:54.910+0000] {subprocess.py:106} INFO -         else:
[2025-03-02T08:15:54.910+0000] {subprocess.py:106} INFO -             url = to_str(parsed_url.url)
[2025-03-02T08:15:54.910+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.910+0000] {subprocess.py:106} INFO -         conn = None
[2025-03-02T08:15:54.910+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.911+0000] {subprocess.py:106} INFO -         # Track whether `conn` needs to be released before
[2025-03-02T08:15:54.911+0000] {subprocess.py:106} INFO -         # returning/raising/recursing. Update this variable if necessary, and
[2025-03-02T08:15:54.912+0000] {subprocess.py:106} INFO -         # leave `release_conn` constant throughout the function. That way, if
[2025-03-02T08:15:54.912+0000] {subprocess.py:106} INFO -         # the function recurses, the original value of `release_conn` will be
[2025-03-02T08:15:54.913+0000] {subprocess.py:106} INFO -         # passed down into the recursive call, and its value will be respected.
[2025-03-02T08:15:54.913+0000] {subprocess.py:106} INFO -         #
[2025-03-02T08:15:54.913+0000] {subprocess.py:106} INFO -         # See issue #651 [1] for details.
[2025-03-02T08:15:54.913+0000] {subprocess.py:106} INFO -         #
[2025-03-02T08:15:54.913+0000] {subprocess.py:106} INFO -         # [1] <https://github.com/urllib3/urllib3/issues/651>
[2025-03-02T08:15:54.914+0000] {subprocess.py:106} INFO -         release_this_conn = release_conn
[2025-03-02T08:15:54.914+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.914+0000] {subprocess.py:106} INFO -         http_tunnel_required = connection_requires_http_tunnel(
[2025-03-02T08:15:54.914+0000] {subprocess.py:106} INFO -             self.proxy, self.proxy_config, destination_scheme
[2025-03-02T08:15:54.914+0000] {subprocess.py:106} INFO -         )
[2025-03-02T08:15:54.914+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.914+0000] {subprocess.py:106} INFO -         # Merge the proxy headers. Only done when not using HTTP CONNECT. We
[2025-03-02T08:15:54.914+0000] {subprocess.py:106} INFO -         # have to copy the headers dict so we can safely change it without those
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO -         # changes being reflected in anyone else's copy.
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO -         if not http_tunnel_required:
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO -             headers = headers.copy()  # type: ignore[attr-defined]
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO -             headers.update(self.proxy_headers)  # type: ignore[union-attr]
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO -         # Must keep the exception bound to a separate variable or else Python 3
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO -         # complains about UnboundLocalError.
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO -         err = None
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.915+0000] {subprocess.py:106} INFO -         # Keep track of whether we cleanly exited the except block. This
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO -         # ensures we do proper cleanup in finally.
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO -         clean_exit = False
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO -         # Rewind body position, if needed. Record current position
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO -         # for future rewinds in the event of a redirect/retry.
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO -         body_pos = set_file_position(body, body_pos)
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO -         try:
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO -             # Request a connection from the queue.
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO -             timeout_obj = self._get_timeout(timeout)
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO -             conn = self._get_conn(timeout=pool_timeout)
[2025-03-02T08:15:54.916+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -             conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -             # Is this a closed/new connection that requires CONNECT tunnelling?
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -             if self.proxy is not None and http_tunnel_required and conn.is_closed:
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -                 try:
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -                     self._prepare_proxy(conn)
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -                 except (BaseSSLError, OSError, SocketTimeout) as e:
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -                     self._raise_timeout(
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -                         err=e, url=self.proxy.url, timeout_value=conn.timeout
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -                     )
[2025-03-02T08:15:54.917+0000] {subprocess.py:106} INFO -                     raise
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO -             # If we're going to release the connection in ``finally:``, then
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO -             # the response doesn't need to know about the connection. Otherwise
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO -             # it will also try to release it and we'll have a double-release
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO -             # mess.
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO -             response_conn = conn if not release_conn else None
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO -             # Make the request on the HTTPConnection object
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO - >           response = self._make_request(
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO -                 conn,
[2025-03-02T08:15:54.918+0000] {subprocess.py:106} INFO -                 method,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 url,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 timeout=timeout_obj,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 body=body,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 headers=headers,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 chunked=chunked,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 retries=retries,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 response_conn=response_conn,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 preload_content=preload_content,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 decode_content=decode_content,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -                 **response_kw,
[2025-03-02T08:15:54.919+0000] {subprocess.py:106} INFO -             )
[2025-03-02T08:15:54.920+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.920+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connectionpool.py:787:
[2025-03-02T08:15:54.920+0000] {subprocess.py:106} INFO - _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
[2025-03-02T08:15:54.920+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connectionpool.py:493: in _make_request
[2025-03-02T08:15:54.920+0000] {subprocess.py:106} INFO -     conn.request(
[2025-03-02T08:15:54.920+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connection.py:445: in request
[2025-03-02T08:15:54.920+0000] {subprocess.py:106} INFO -     self.endheaders()
[2025-03-02T08:15:54.921+0000] {subprocess.py:106} INFO - /usr/local/lib/python3.12/http/client.py:1333: in endheaders
[2025-03-02T08:15:54.921+0000] {subprocess.py:106} INFO -     self._send_output(message_body, encode_chunked=encode_chunked)
[2025-03-02T08:15:54.921+0000] {subprocess.py:106} INFO - /usr/local/lib/python3.12/http/client.py:1093: in _send_output
[2025-03-02T08:15:54.921+0000] {subprocess.py:106} INFO -     self.send(msg)
[2025-03-02T08:15:54.921+0000] {subprocess.py:106} INFO - /usr/local/lib/python3.12/http/client.py:1037: in send
[2025-03-02T08:15:54.921+0000] {subprocess.py:106} INFO -     self.connect()
[2025-03-02T08:15:54.921+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connection.py:276: in connect
[2025-03-02T08:15:54.921+0000] {subprocess.py:106} INFO -     self.sock = self._new_conn()
[2025-03-02T08:15:54.921+0000] {subprocess.py:106} INFO - _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
[2025-03-02T08:15:54.922+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.922+0000] {subprocess.py:106} INFO - self = <urllib3.connection.HTTPConnection object at 0xffff8d35a690>
[2025-03-02T08:15:54.922+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.922+0000] {subprocess.py:106} INFO -     def _new_conn(self) -> socket.socket:
[2025-03-02T08:15:54.922+0000] {subprocess.py:106} INFO -         """Establish a socket connection and set nodelay settings on it.
[2025-03-02T08:15:54.922+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.922+0000] {subprocess.py:106} INFO -         :return: New socket connection.
[2025-03-02T08:15:54.922+0000] {subprocess.py:106} INFO -         """
[2025-03-02T08:15:54.922+0000] {subprocess.py:106} INFO -         try:
[2025-03-02T08:15:54.923+0000] {subprocess.py:106} INFO -             sock = connection.create_connection(
[2025-03-02T08:15:54.923+0000] {subprocess.py:106} INFO -                 (self._dns_host, self.port),
[2025-03-02T08:15:54.923+0000] {subprocess.py:106} INFO -                 self.timeout,
[2025-03-02T08:15:54.923+0000] {subprocess.py:106} INFO -                 source_address=self.source_address,
[2025-03-02T08:15:54.923+0000] {subprocess.py:106} INFO -                 socket_options=self.socket_options,
[2025-03-02T08:15:54.923+0000] {subprocess.py:106} INFO -             )
[2025-03-02T08:15:54.923+0000] {subprocess.py:106} INFO -         except socket.gaierror as e:
[2025-03-02T08:15:54.923+0000] {subprocess.py:106} INFO - >           raise NameResolutionError(self.host, self, e) from e
[2025-03-02T08:15:54.923+0000] {subprocess.py:106} INFO - E           urllib3.exceptions.NameResolutionError: <urllib3.connection.HTTPConnection object at 0xffff8d35a690>: Failed to resolve 'remote_chromedriver' ([Errno -2] Name or service not known)
[2025-03-02T08:15:54.924+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.924+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connection.py:205: NameResolutionError
[2025-03-02T08:15:54.924+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.924+0000] {subprocess.py:106} INFO - The above exception was the direct cause of the following exception:
[2025-03-02T08:15:54.924+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.924+0000] {subprocess.py:106} INFO - mock_chrome = <MagicMock name='Chrome' id='281473060952720'>
[2025-03-02T08:15:54.924+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.924+0000] {subprocess.py:106} INFO -     @patch("Scrape_script.webdriver.Chrome")
[2025-03-02T08:15:54.924+0000] {subprocess.py:106} INFO -     def test_start_webdriver(mock_chrome):
[2025-03-02T08:15:54.925+0000] {subprocess.py:106} INFO -         """Test WebDriver starts correctly."""
[2025-03-02T08:15:54.925+0000] {subprocess.py:106} INFO - >       driver = start_webdriver()
[2025-03-02T08:15:54.925+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.925+0000] {subprocess.py:106} INFO - /opt/***/dags/src/test_scraper.py:104:
[2025-03-02T08:15:54.925+0000] {subprocess.py:106} INFO - _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
[2025-03-02T08:15:54.925+0000] {subprocess.py:106} INFO - /opt/***/dags/src/Scrape_script.py:130: in start_webdriver
[2025-03-02T08:15:54.925+0000] {subprocess.py:106} INFO -     driver_ = webdriver.Remote(f"{remote_webdriver}:4444/wd/hub", options=options)
[2025-03-02T08:15:54.925+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/selenium/webdriver/remote/webdriver.py:250: in __init__
[2025-03-02T08:15:54.926+0000] {subprocess.py:106} INFO -     self.start_session(capabilities)
[2025-03-02T08:15:54.926+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/selenium/webdriver/remote/webdriver.py:342: in start_session
[2025-03-02T08:15:54.926+0000] {subprocess.py:106} INFO -     response = self.execute(Command.NEW_SESSION, caps)["value"]
[2025-03-02T08:15:54.926+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/selenium/webdriver/remote/webdriver.py:427: in execute
[2025-03-02T08:15:54.926+0000] {subprocess.py:106} INFO -     response = self.command_executor.execute(driver_command, params)
[2025-03-02T08:15:54.926+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/selenium/webdriver/remote/remote_connection.py:404: in execute
[2025-03-02T08:15:54.926+0000] {subprocess.py:106} INFO -     return self._request(command_info[0], url, body=data)
[2025-03-02T08:15:54.927+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/selenium/webdriver/remote/remote_connection.py:428: in _request
[2025-03-02T08:15:54.927+0000] {subprocess.py:106} INFO -     response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
[2025-03-02T08:15:54.927+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/_request_methods.py:143: in request
[2025-03-02T08:15:54.927+0000] {subprocess.py:106} INFO -     return self.request_encode_body(
[2025-03-02T08:15:54.927+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/_request_methods.py:278: in request_encode_body
[2025-03-02T08:15:54.927+0000] {subprocess.py:106} INFO -     return self.urlopen(method, url, **extra_kw)
[2025-03-02T08:15:54.928+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/poolmanager.py:443: in urlopen
[2025-03-02T08:15:54.928+0000] {subprocess.py:106} INFO -     response = conn.urlopen(method, u.request_uri, **kw)
[2025-03-02T08:15:54.928+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connectionpool.py:871: in urlopen
[2025-03-02T08:15:54.928+0000] {subprocess.py:106} INFO -     return self.urlopen(
[2025-03-02T08:15:54.928+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connectionpool.py:871: in urlopen
[2025-03-02T08:15:54.928+0000] {subprocess.py:106} INFO -     return self.urlopen(
[2025-03-02T08:15:54.928+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connectionpool.py:871: in urlopen
[2025-03-02T08:15:54.929+0000] {subprocess.py:106} INFO -     return self.urlopen(
[2025-03-02T08:15:54.929+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/connectionpool.py:841: in urlopen
[2025-03-02T08:15:54.929+0000] {subprocess.py:106} INFO -     retries = retries.increment(
[2025-03-02T08:15:54.929+0000] {subprocess.py:106} INFO - _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
[2025-03-02T08:15:54.929+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.930+0000] {subprocess.py:106} INFO - self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
[2025-03-02T08:15:54.930+0000] {subprocess.py:106} INFO - method = 'POST', url = '/wd/hub/session', response = None
[2025-03-02T08:15:54.930+0000] {subprocess.py:106} INFO - error = NameResolutionError("<urllib3.connection.HTTPConnection object at 0xffff8d35a690>: Failed to resolve 'remote_chromedriver' ([Errno -2] Name or service not known)")
[2025-03-02T08:15:54.930+0000] {subprocess.py:106} INFO - _pool = <urllib3.connectionpool.HTTPConnectionPool object at 0xffff8d35acc0>
[2025-03-02T08:15:54.930+0000] {subprocess.py:106} INFO - _stacktrace = <traceback object at 0xffff8d4806c0>
[2025-03-02T08:15:54.930+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.930+0000] {subprocess.py:106} INFO -     def increment(
[2025-03-02T08:15:54.930+0000] {subprocess.py:106} INFO -         self,
[2025-03-02T08:15:54.930+0000] {subprocess.py:106} INFO -         method: str | None = None,
[2025-03-02T08:15:54.931+0000] {subprocess.py:106} INFO -         url: str | None = None,
[2025-03-02T08:15:54.931+0000] {subprocess.py:106} INFO -         response: BaseHTTPResponse | None = None,
[2025-03-02T08:15:54.931+0000] {subprocess.py:106} INFO -         error: Exception | None = None,
[2025-03-02T08:15:54.931+0000] {subprocess.py:106} INFO -         _pool: ConnectionPool | None = None,
[2025-03-02T08:15:54.931+0000] {subprocess.py:106} INFO -         _stacktrace: TracebackType | None = None,
[2025-03-02T08:15:54.931+0000] {subprocess.py:106} INFO -     ) -> Self:
[2025-03-02T08:15:54.931+0000] {subprocess.py:106} INFO -         """Return a new Retry object with incremented retry counters.
[2025-03-02T08:15:54.931+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.931+0000] {subprocess.py:106} INFO -         :param response: A response object, or None, if the server did not
[2025-03-02T08:15:54.932+0000] {subprocess.py:106} INFO -             return a response.
[2025-03-02T08:15:54.932+0000] {subprocess.py:106} INFO -         :type response: :class:`~urllib3.response.BaseHTTPResponse`
[2025-03-02T08:15:54.932+0000] {subprocess.py:106} INFO -         :param Exception error: An error encountered during the request, or
[2025-03-02T08:15:54.932+0000] {subprocess.py:106} INFO -             None if the response was received successfully.
[2025-03-02T08:15:54.932+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.932+0000] {subprocess.py:106} INFO -         :return: A new ``Retry`` object.
[2025-03-02T08:15:54.932+0000] {subprocess.py:106} INFO -         """
[2025-03-02T08:15:54.932+0000] {subprocess.py:106} INFO -         if self.total is False and error:
[2025-03-02T08:15:54.932+0000] {subprocess.py:106} INFO -             # Disabled, indicate to re-raise the error.
[2025-03-02T08:15:54.933+0000] {subprocess.py:106} INFO -             raise reraise(type(error), error, _stacktrace)
[2025-03-02T08:15:54.933+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.933+0000] {subprocess.py:106} INFO -         total = self.total
[2025-03-02T08:15:54.933+0000] {subprocess.py:106} INFO -         if total is not None:
[2025-03-02T08:15:54.933+0000] {subprocess.py:106} INFO -             total -= 1
[2025-03-02T08:15:54.933+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.933+0000] {subprocess.py:106} INFO -         connect = self.connect
[2025-03-02T08:15:54.933+0000] {subprocess.py:106} INFO -         read = self.read
[2025-03-02T08:15:54.933+0000] {subprocess.py:106} INFO -         redirect = self.redirect
[2025-03-02T08:15:54.934+0000] {subprocess.py:106} INFO -         status_count = self.status
[2025-03-02T08:15:54.934+0000] {subprocess.py:106} INFO -         other = self.other
[2025-03-02T08:15:54.934+0000] {subprocess.py:106} INFO -         cause = "unknown"
[2025-03-02T08:15:54.934+0000] {subprocess.py:106} INFO -         status = None
[2025-03-02T08:15:54.934+0000] {subprocess.py:106} INFO -         redirect_location = None
[2025-03-02T08:15:54.934+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.934+0000] {subprocess.py:106} INFO -         if error and self._is_connection_error(error):
[2025-03-02T08:15:54.934+0000] {subprocess.py:106} INFO -             # Connect retry?
[2025-03-02T08:15:54.935+0000] {subprocess.py:106} INFO -             if connect is False:
[2025-03-02T08:15:54.935+0000] {subprocess.py:106} INFO -                 raise reraise(type(error), error, _stacktrace)
[2025-03-02T08:15:54.935+0000] {subprocess.py:106} INFO -             elif connect is not None:
[2025-03-02T08:15:54.935+0000] {subprocess.py:106} INFO -                 connect -= 1
[2025-03-02T08:15:54.935+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.935+0000] {subprocess.py:106} INFO -         elif error and self._is_read_error(error):
[2025-03-02T08:15:54.935+0000] {subprocess.py:106} INFO -             # Read retry?
[2025-03-02T08:15:54.935+0000] {subprocess.py:106} INFO -             if read is False or method is None or not self._is_method_retryable(method):
[2025-03-02T08:15:54.936+0000] {subprocess.py:106} INFO -                 raise reraise(type(error), error, _stacktrace)
[2025-03-02T08:15:54.936+0000] {subprocess.py:106} INFO -             elif read is not None:
[2025-03-02T08:15:54.936+0000] {subprocess.py:106} INFO -                 read -= 1
[2025-03-02T08:15:54.936+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.936+0000] {subprocess.py:106} INFO -         elif error:
[2025-03-02T08:15:54.936+0000] {subprocess.py:106} INFO -             # Other retry?
[2025-03-02T08:15:54.936+0000] {subprocess.py:106} INFO -             if other is not None:
[2025-03-02T08:15:54.936+0000] {subprocess.py:106} INFO -                 other -= 1
[2025-03-02T08:15:54.936+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO -         elif response and response.get_redirect_location():
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO -             # Redirect retry?
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO -             if redirect is not None:
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO -                 redirect -= 1
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO -             cause = "too many redirects"
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO -             response_redirect_location = response.get_redirect_location()
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO -             if response_redirect_location:
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO -                 redirect_location = response_redirect_location
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO -             status = response.status
[2025-03-02T08:15:54.937+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.938+0000] {subprocess.py:106} INFO -         else:
[2025-03-02T08:15:54.938+0000] {subprocess.py:106} INFO -             # Incrementing because of a server error like a 500 in
[2025-03-02T08:15:54.938+0000] {subprocess.py:106} INFO -             # status_forcelist and the given method is in the allowed_methods
[2025-03-02T08:15:54.938+0000] {subprocess.py:106} INFO -             cause = ResponseError.GENERIC_ERROR
[2025-03-02T08:15:54.938+0000] {subprocess.py:106} INFO -             if response and response.status:
[2025-03-02T08:15:54.938+0000] {subprocess.py:106} INFO -                 if status_count is not None:
[2025-03-02T08:15:54.938+0000] {subprocess.py:106} INFO -                     status_count -= 1
[2025-03-02T08:15:54.938+0000] {subprocess.py:106} INFO -                 cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
[2025-03-02T08:15:54.938+0000] {subprocess.py:106} INFO -                 status = response.status
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO -         history = self.history + (
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO -             RequestHistory(method, url, error, status, redirect_location),
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO -         )
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO -         new_retry = self.new(
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO -             total=total,
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO -             connect=connect,
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO -             read=read,
[2025-03-02T08:15:54.939+0000] {subprocess.py:106} INFO -             redirect=redirect,
[2025-03-02T08:15:54.940+0000] {subprocess.py:106} INFO -             status=status_count,
[2025-03-02T08:15:54.940+0000] {subprocess.py:106} INFO -             other=other,
[2025-03-02T08:15:54.940+0000] {subprocess.py:106} INFO -             history=history,
[2025-03-02T08:15:54.940+0000] {subprocess.py:106} INFO -         )
[2025-03-02T08:15:54.940+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.940+0000] {subprocess.py:106} INFO -         if new_retry.is_exhausted():
[2025-03-02T08:15:54.940+0000] {subprocess.py:106} INFO -             reason = error or ResponseError(cause)
[2025-03-02T08:15:54.940+0000] {subprocess.py:106} INFO - >           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
[2025-03-02T08:15:54.940+0000] {subprocess.py:106} INFO - E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='remote_chromedriver', port=4444): Max retries exceeded with url: /wd/hub/session (Caused by NameResolutionError("<urllib3.connection.HTTPConnection object at 0xffff8d35a690>: Failed to resolve 'remote_chromedriver' ([Errno -2] Name or service not known)"))
[2025-03-02T08:15:54.941+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.941+0000] {subprocess.py:106} INFO - /home/***/.local/lib/python3.12/site-packages/urllib3/util/retry.py:519: MaxRetryError
[2025-03-02T08:15:54.941+0000] {subprocess.py:106} INFO - ------------------------------ Captured log call -------------------------------
[2025-03-02T08:15:54.941+0000] {subprocess.py:106} INFO - WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NameResolutionError("<urllib3.connection.HTTPConnection object at 0xffff8d35ad20>: Failed to resolve 'remote_chromedriver' ([Errno -2] Name or service not known)")': /wd/hub/session
[2025-03-02T08:15:54.941+0000] {subprocess.py:106} INFO - WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NameResolutionError("<urllib3.connection.HTTPConnection object at 0xffff8d35aab0>: Failed to resolve 'remote_chromedriver' ([Errno -2] Name or service not known)")': /wd/hub/session
[2025-03-02T08:15:54.941+0000] {subprocess.py:106} INFO - WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NameResolutionError("<urllib3.connection.HTTPConnection object at 0xffff8d35a8d0>: Failed to resolve 'remote_chromedriver' ([Errno -2] Name or service not known)")': /wd/hub/session
[2025-03-02T08:15:54.941+0000] {subprocess.py:106} INFO - =============================== warnings summary ===============================
[2025-03-02T08:15:54.941+0000] {subprocess.py:106} INFO - test_scraper.py::test_start_webdriver
[2025-03-02T08:15:54.942+0000] {subprocess.py:106} INFO -   /home/***/.local/lib/python3.12/site-packages/urllib3/_request_methods.py:278: DeprecationWarning: URLs without a scheme (ie 'https://') are deprecated and will raise an error in a future version of urllib3. To avoid this DeprecationWarning ensure all URLs start with 'https://' or 'http://'. Read more in this issue: https://github.com/urllib3/urllib3/issues/2920
[2025-03-02T08:15:54.942+0000] {subprocess.py:106} INFO -     return self.urlopen(method, url, **extra_kw)
[2025-03-02T08:15:54.942+0000] {subprocess.py:106} INFO - 
[2025-03-02T08:15:54.942+0000] {subprocess.py:106} INFO - -- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
[2025-03-02T08:15:54.942+0000] {subprocess.py:106} INFO - =========================== short test summary info ============================
[2025-03-02T08:15:54.942+0000] {subprocess.py:106} INFO - FAILED ../../opt/***/dags/src/test_scraper.py::test_start_webdriver - url...
[2025-03-02T08:15:54.942+0000] {subprocess.py:106} INFO - ==================== 1 failed, 6 passed, 1 warning in 0.66s ====================
[2025-03-02T08:15:54.943+0000] {subprocess.py:110} INFO - Command exited with return code 1
[2025-03-02T08:15:54.968+0000] {taskinstance.py:3313} ERROR - Task failed with exception
Traceback (most recent call last):
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/taskinstance.py", line 768, in _execute_task
    result = _execute_callable(context=context, **execute_callable_kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/taskinstance.py", line 734, in _execute_callable
    return ExecutionCallableRunner(
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/utils/operator_helpers.py", line 252, in run
    return self.func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/baseoperator.py", line 424, in wrapper
    return func(self, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/operators/bash.py", line 276, in execute
    raise AirflowException(
airflow.exceptions.AirflowException: Bash command failed. The command returned a non-zero exit code 1.
[2025-03-02T08:15:54.979+0000] {logging_mixin.py:190} INFO - Task instance in failure state
[2025-03-02T08:15:54.980+0000] {logging_mixin.py:190} INFO - Task start:2025-03-02 08:15:52.925773+00:00 end:2025-03-02 08:15:54.978915+00:00 duration:2.053142
[2025-03-02T08:15:54.980+0000] {logging_mixin.py:190} INFO - Task:<Task(BashOperator): run_unittests> dag:<DAG: scraping_pipeline_gcs> dagrun:<DagRun scraping_pipeline_gcs @ 2025-03-02 08:15:48.190529+00:00: manual__2025-03-02T08:15:48.190529+00:00, state:running, queued_at: 2025-03-02 08:15:48.220553+00:00. externally triggered: True>
[2025-03-02T08:15:54.980+0000] {logging_mixin.py:190} INFO - Failure caused by Bash command failed. The command returned a non-zero exit code 1.
[2025-03-02T08:15:54.980+0000] {taskinstance.py:1226} INFO - Marking task as UP_FOR_RETRY. dag_id=scraping_pipeline_gcs, task_id=run_unittests, run_id=manual__2025-03-02T08:15:48.190529+00:00, execution_date=20250302T081548, start_date=20250302T081552, end_date=20250302T081554
[2025-03-02T08:15:55.001+0000] {taskinstance.py:341} INFO - ::group::Post task execution logs
[2025-03-02T08:15:55.002+0000] {standard_task_runner.py:124} ERROR - Failed to execute job 52 for task run_unittests (Bash command failed. The command returned a non-zero exit code 1.; 1670)
Traceback (most recent call last):
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/task/task_runner/standard_task_runner.py", line 117, in _start_by_fork
    ret = args.func(args, dag=self.dag)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/cli/cli_config.py", line 49, in command
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/utils/cli.py", line 116, in wrapper
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/cli/commands/task_command.py", line 483, in task_run
    task_return_code = _run_task_by_selected_method(args, _dag, ti)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/cli/commands/task_command.py", line 256, in _run_task_by_selected_method
    return _run_raw_task(args, ti)
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/cli/commands/task_command.py", line 341, in _run_raw_task
    return ti._run_raw_task(
           ^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/utils/session.py", line 97, in wrapper
    return func(*args, session=session, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/taskinstance.py", line 3006, in _run_raw_task
    return _run_raw_task(
           ^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/taskinstance.py", line 274, in _run_raw_task
    TaskInstance._execute_task_with_callbacks(
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/taskinstance.py", line 3161, in _execute_task_with_callbacks
    result = self._execute_task(context, task_orig)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/taskinstance.py", line 3185, in _execute_task
    return _execute_task(self, context, task_orig)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/taskinstance.py", line 768, in _execute_task
    result = _execute_callable(context=context, **execute_callable_kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/taskinstance.py", line 734, in _execute_callable
    return ExecutionCallableRunner(
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/utils/operator_helpers.py", line 252, in run
    return self.func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/models/baseoperator.py", line 424, in wrapper
    return func(self, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/airflow/.local/lib/python3.12/site-packages/airflow/operators/bash.py", line 276, in execute
    raise AirflowException(
airflow.exceptions.AirflowException: Bash command failed. The command returned a non-zero exit code 1.
[2025-03-02T08:15:55.018+0000] {local_task_job_runner.py:266} INFO - Task exited with return code 1
[2025-03-02T08:15:55.047+0000] {taskinstance.py:3901} INFO - 0 downstream tasks scheduled from follow-on schedule check
[2025-03-02T08:15:55.048+0000] {local_task_job_runner.py:245} INFO - ::endgroup::
